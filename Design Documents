				Design Document


Something about the Game – 

I have made a game called Battle City for my 112-term project.  I have used Python for doing so. I am not using any external modules. 
For graphics, I am using Tkinter(). 

This project is my take of the Battle City. It will take a number of features from the game itself but has some of my original ideas as well.

The gameplay for Battle City is exactly like the one for the original game.


Design 

I have used top-down design for making this game. I have used Model-View-Controller to make this game. My game is in a file called Term_Project.py that has a class called BattleCity() and a class called runGame(). The class BattleCity has all the components of the game. It has keyPressed() and timerFired() as the Controllers. It has redrawAll() controlling the view for the user.  For the graphics, I have used images (from Google images) and the Tkinter() library. 

For my model, I have a board in which the “Defender” is represented as “Defender” and the three enemies are represented as “enemy1”,”enemy2” and “enemy3”. The user playing as the enemy is represented as “Uenemy”. The blocks on the board have three states (on each higher state, they become smaller). The three states of the blocks are  - block1, block2, and block3. As for the bullets, I have stored the bullets as tuples on the board. Each such tuple has its present location and the direction in which it is moving. 

Moreover, for moving between different pages, I have used buttons. 

Another component to my game is the level editor, which is stored in a separate file called ‘levelEditor.py’. This file is also imported in Term_Project.py. Then the runGame() is used to link both these pieces together into one window.  Moreover the level editor allows the user to save the board they make and load the board they made earlier.  
I have also used Delta graphics for moving around the blocks in the level editor.
Test Functions

Most of the functions in my game are graphics based, so I have tested most of the visually by looking at them and seeing if they are doing the desired thing. There are a few test functions that I have to test the non-graphic code.

The User Interface

When the user runs the program, there is the main menu screen with four options  - 
•	Play Game
•	Play On Own Level
•	Make Your Own Level
•	Quit Game

The “Play Game” option loads the board with the inbuilt board. 
The “Play On Own Level” asks the user to find a board from the directories in which an earlier made board is saved.
The  “Make Your Own Level” takes the user to the Level Editor where the user can make his own board and save it.
The “Quit Game” takes the user to the credits page from where in the user can exit the game.

The Level Editor  (UI) – This allows the user to make their level. It has two buttons on the top. “Block” and “Grass”. On clicking the “Grass”, the user can place the grass on the board and on clicking the block, the user can place the blocks on the board.

If the user wants to change the background color, the user can press ‘c’ to select from a variety of colors. 

Also, there are two modes to this editor, one is ‘Draw Mode’ and the other is “Erase” mode. In “Draw Mode”, the user can draw whatever he wants and in the “Erase Mode”, the user can erase whatever he wants by clicking on it.

The Game Play  (Controls)- 
The user controls the bots by using arrow keys and shoots in the direction he is pointing by pressing the spacebar. 

Saving the edited boards – 
I have used Pickle to do so. These are my imports - 
from Tkinter import *
import copy
import random
from random import choice
import time
from levelEditor import levelEditor
import pickle, pprint
from tkFileDialog import askopenfilename

The use of random is to make the “power up”(things to give extra life) to the user appear on the board in an interval of five seconds randomly.

Also, for the movement of the CPU controlled bots, they move in a particular direction until they are given a reason to change their direction. Reasons to change their direction would be if they hit a barrier or may collide with the user.
